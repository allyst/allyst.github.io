<html>
    <head>
        <meta charset="UTF-8">
        <title>
            LLSN Documentation
        </title>
        <link href="/build/styles.min.css" type="text/css" rel="stylesheet" />
        <script src="/build/main.js"></script>
    </head>
    <body class="llsn">
        <div class="language-selector"><a href="/opensource/llsn/">EN</a></div>
        <div class="content">
            <div class="logo"><img src="/img/doclogo.png" /></div>
            <div class="back"><a class="back__link" href="/">Back</a></div>
            <h1 class="b-header">LLSN specification (version 1)</h1>
            <p>Это бинарный формат кодирования структурированной информации,
                разработанный специально для интеграционной платформы Allyst.</p>
            <ul class="link-menu">
                <li class="link-menu__item">
                    <a class="link-menu__link" href="#prerequisites">Предпосылки</a>
                </li>
                <li class="link-menu__item">
                    <a class="link-menu__link" href="#coding-styles">Общая структура кодирования</a>
                </li>
                <li class="link-menu__item">
                    <a class="link-menu__link" href="#supported-types">Поддерживаемые типы</a>
                    <ul class="link-menu">
                        <li class="link-menu__item">
                            <a class="link-menu__link" href="#base-types">Базовые типы</a>
                        </li>
                        <li class="link-menu__item">
                            <a class="link-menu__link" href="#secondary-types">Вспомогательные типы</a>
                        </li>
                    </ul>
                </li>
                <li class="link-menu__item">
                    <a class="link-menu__link" href="#null-flags">Механизмы NULL-флагов</a>
                </li>
                <li class="link-menu__item">
                    <a class="link-menu__link" href="#available-implementation">Доступные реализации на различных языках</a>
                </li>
            </ul>


            <h2 class="m-header" id="prerequisites">Предпосылки</h2>
            <p>
                Первый и самый главный тезис - машины должны общаться на машинном языке.
                Текстовые форматы и протоколы потребляют неоправданно большие вычислительные ресурсы.
                В среде разработчиков то и дело возникают споры относительно преимуществ и недостатков текстового
                и бинарного представления данных в обмене информацией между ИТ-системами.
                Идеология интеграционной платформы Allyst - максимальная эффективность ресурсов,
                как вычислительных, так и транспортных.
            </p>
            <p>
                На первый взгляд, уже имеется достаточно инструментов, чтобы закодировать какую-либо структуру данных
                в бинарный вид. Например, JSONB, ProtoBuffer, Thrift и тд. Каждый из них очень популярен.
                Каждый из них имеет ряд перимуществ и недостатков.
                Для чего же было необходимо придумывать LLSN? Ниже представлены требования для формата,
                который бы смог обеспечить потребности интеграционной платформы:
            </p>
            <p>
                <ol>
                    <li>Иметь минимальный, но достаточный набор типов данных</li>
                    <li>Исключить избыточное кодирование служебных данных</li>
                    <li>Иметь механизмы размещения тяжелых данных в конец закодированного сообщения
                        (особенно важный функционал, используемый в интеграционной платформе Allyst)</li>
                    <li>Уметь упаковывать структуры любой сложности и вложенности</li>
                    <li>Поддерживать упаковку древовидных структур</li>
                    <li>Обеспечить поддержку NULL значений</li>
                    <li>Уметь кодировать сверх тяжелые данные (например, массив террабайтных файлов)</li>
                </ol>
            </p>
            <p>
                К сожалению, имеющиеся инструменты кодирования данных в бинарное представление
                не отвечают всем требованиям в полной мере.
            </p>
            <h2 class="m-header" id="coding-styles">Общая структура кодирования</h2>
            <p>
                В основе модели кодирования LLSN лежит цель оптимизировать формат.
                Это достигается следующими механизмами
            </p>
            <ol>
                <li>Механизм дерева типов. в процессе кодирования данных формируется дерево типов.
                    Если происходит повторных проход по ветви такого дерева, то типы данных уже не кодируются.
                    Например, если кодируется массив, то тип элементов будет закодирован только один раз.</li>
                <li>Механизм хвостовой упаковки. Если при кодировании данных указан threshold, то все данные,
                    превышающие это значение должны быть закодированны в конце бинарного пакета в порядке следования.
                    Этот механизм используется в платформе Allyst для возможности маршрутизации пакетов используя
                    частичное декодирование.</li>
                <li>Механизм NULL-флагов. Совместно с механизмом дерева типов позволяет
                    до 80% оптимизировать размер закодированных служебных даных</li>
            </ol>
            <p>Общий формат бинарного представления:</p>
            <p>[version:4bit] [threshold:12bit] [data] [tail: data (strings, blobs, files) that are exceed the specified threshold]</p>
            <p>Способы кодирования в разных языках программирования (ЯП) могут значительно отличаться в силу своих особенностей.
                Если ЯП не позволяет точно определять тип кодируемой информации,
                то должны использоваться карты декларации, в которых описывается структура кодируемых данных.
                Формат карт декларации свободный. Например, в ЯП Erlang нет возможности точно определить кодируемый
                тип данных, поэтому при кодировании указывается декларативная карта, описывающая структуру данных.
                Однако, для языка Golang декларативная карта не используется поскольку данные в этом языке является
                жестко типизированными (см примеры в разделе Доступные реализации).</p>


            <h2 class="m-header" id="supported-types">Поддерживаемые типы</h2>
            <p>Набор типов был сформирован как общий знаменатель базовых типов, представленных во всех популярных
                языках программирования (C/C++, Java, Python, PHP и тд). Такой подход обусловлен единственной целью -
                обеспечить бесшовность трансфера структурированных данных между системами, написанными на различных языках.
                Любая реализация LLSN кодировщика обязана придерживаться принципа - native type.
                Например, если осуществляется обмен данными между двумя системами, написанными на языках Python и Golang,
                то трансфер данных должер происходить следующим образом: Datetime.Datetime (Python) >> DATE (LLSN) >> time.Time (Golang).
                Такие преобразования с типами должны происходить автоматически.</p>
            <p>Всего имеется 9 базовых типов и несколько вспомогательных. Каждый такой тип имеет NULL-дублер.
                Более подробную информацию смотрите Таблица идентификаторов типов.</p>


            <h2 class="m-header" id="base-types">Базовые типы</h2>
            <p>
                <h3 class="s-header">NUMBER</h3>
                <span>Знаковое целое 64битное число. Однако, при кодировании может использоваться вспомогательный тип -
                    UNUMBER (беззнаковое целое) для более эффективного бинарного представления.
                    Формат не несет в себе какую-либо информацию о размерности исходного типа кодируемого
                    числа (int8, int16 и тд).</span>
            </p>
            <p>
                <h3 class="s-header">FLOAT</h3>
                <span>64битное число с плавающей запятой. </span>
            </p>
            <h2 class="m-header" id="secondary-types">Вспомогательные типы</h2>
            <p>
            <h3 class="s-header">ARRAYN</h3>
            <span>при кодировании типа ARRAY необходимо просканировать массив на наличие NULL значений.
                если таковые присутствуют, то кодируется тип ARRAYN, иначе - ARRAY.</span>
            </p>

            <h2 class="m-header" id="available-implementation">Общая структура кодирования</h2>
            <div class="available-lang">Golang  <a href="#github">ссылка на гитхаб</a></div>
            <div class="available-lang__example">
                <!-- СОХРАНИТЬ СТРУКТУРУ! Тэг "pre" должен следовать за блоком с классом "js-lang-example"-->
                <a href="#example" class="available-lang__example-link js-lang-example">пример использования</a>
                <pre class="code-example hide">
                    <code>
package main

import "fmt"

func main() {
    var a [5]int
    fmt.Println("emp:", a)
}
</code>
                </pre>
            </div>
        </div>
    </body>
</html>
